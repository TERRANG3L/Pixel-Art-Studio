<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Pixel Art Studio Pro++</title>
    <style>
        :root {
            --primary: #4a90e2;
            --secondary: #7ed321;
            --background: #2d2d37;
            --panel: #3a3a4a;
            --text: #f0f0f5;
        }

        body {
            display: grid;
            grid-template-columns: 220px 1fr;
            margin: 0;
            min-height: 100vh;
            background: var(--background);
            font-family: 'Segoe UI', system-ui;
            color: var(--text);
            overflow: hidden;
        }

        .tool-panel {
            background: var(--panel);
            padding: 20px;
            border-right: 2px solid #25252d;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow-y: auto;
            position: relative;
        }

        .color-picker {
            background: #40404d;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            position: relative;
        }

        .color-preview {
            width: 100%;
            height: 60px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid var(--text);
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            background: none;
            cursor: pointer;
        }

        .tools-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .tool-btn {
            background: #40404d;
            border: none;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .tool-btn.active {
            background: var(--primary);
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
        }

        .main-area {
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            gap: 25px;
            flex-grow: 1;
            overflow: auto;
        }

        #gridContainer {
            transform-origin: center center;
            transition: transform 0.2s;
            margin: auto;
        }

        #grid {
            display: grid;
            gap: 0;
            background: transparent;
            margin: 20px auto;
        }

        .pixel {
            width: 20px;
            height: 20px;
            background: #fff;
            cursor: crosshair;
            transition: background 0.1s;
            border: 1px solid transparent;
            -webkit-user-drag: none;
            user-select: none;
        }

        .grid-visible .pixel {
            border: 1px solid #4a4a5a;
        }

        .panel-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 10px 20px;
            background: var(--primary);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }

        .grid-config {
            display: flex;
            gap: 10px;
            align-items: center;
            position: relative;
        }

        .color-swatch-container {
            position: relative;
        }

        .delete-color {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ff4444;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: none;
            cursor: pointer;
            border: 2px solid white;
        }

        .color-swatch-container:hover .delete-color {
            display: block;
        }

        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-swatch.selected {
            border-color: var(--text);
            transform: scale(1.1);
        }

        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--panel);
            padding: 10px;
            border-radius: 8px;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .symmetry-toggle {
            cursor: pointer;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .custom-confirm {
            position: absolute;
            background: var(--panel);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
            min-width: 200px;
            text-align: center;
        }

        .paleta-container {
            max-height: 300px;
            overflow-y: auto;
        }

        .paleta-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .paleta-selector select {
            background: var(--background);
            color: var(--text);
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
        }

        #symmetryStatus {
            font-size: 0.8em;
            color: var(--text);
        }

        .mirror-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mirror-controls button.active {
            background: var(--secondary);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .mirror-controls select {
            background: var(--background);
            color: var(--text);
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="custom-confirm" id="confirmDialog">
        <p>¬øSeguro que quieres eliminar este color?</p>
        <div style="display: flex; gap: 10px; margin-top: 15px; justify-content: center;">
            <button onclick="handleConfirm(true)">S√≠</button>
            <button onclick="handleConfirm(false)">No</button>
        </div>
    </div>

    <div class="tool-panel">
        <div>
            <div class="color-picker">
                <div class="color-preview" id="colorPreview"></div>
                <input type="color" id="colorInput" value="#ff0000">
                <div class="tools-grid" style="margin-top: 20px;">
                    <button class="tool-btn active" data-tool="brush">
                        <span>üñåÔ∏è</span>
                        Pincel
                    </button>
                    <button class="tool-btn" data-tool="eraser">
                        <span>üßπ</span>
                        Borrador
                    </button>
                    <button class="tool-btn" data-tool="fill">
                        <span>üé®</span>
                        Relleno
                    </button>
                    <button class="tool-btn" data-tool="picker">
                        <span>üëÜ</span>
                        Selector
                    </button>
                </div>
            </div>

            <div class="color-picker">
                <div class="paleta-selector">
                    <button onclick="newPalette()">Nueva</button>
                    <select id="paletteSelector" onchange="changePalette(this.value)"></select>
                </div>
                <div class="paleta-container">
                    <div id="colorPalette" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;"></div>
                </div>
                <button onclick="addToPalette()" style="margin-top: 15px; width: 100%;">
                    A√±adir a paleta
                </button>
            </div>
        </div>

        <div class="panel-controls">
            <div class="mirror-controls">
                <button onclick="toggleMirrorMode()" class="">
                    ü™û Modo Espejo
                </button>
                <select onchange="changeMirrorType(this.value)">
                    <option value="vertical">Vertical</option>
                    <option value="horizontal">Horizontal</option>
                    <option value="diagonal">Diagonal</option>
                </select>
            </div>
            <button onclick="toggleGrid()">üî≤ Grid</button>
            <button onclick="clearGrid()">üßπ Limpiar</button>
            <button onclick="saveArt()">üíæ Guardar</button>
        </div>
    </div>

    <div class="main-area">
        <div id="gridContainer">
            <div id="grid"></div>
        </div>
        <div class="grid-config">
            <input type="number" id="cols" value="16" min="8" max="64">
            <span>x</span>
            <input type="number" id="rows" value="16" min="8" max="64">
            <span class="symmetry-toggle" onclick="toggleSymmetry()">
                üîó <span id="symmetryStatus">Activar Simetria</span>
            </span>
            <button onclick="updateGrid()">Actualizar</button>
        </div>
    </div>

    <div class="zoom-controls">
        <button onclick="adjustZoom(-0.1)">‚ûñ</button>
        <span id="zoomLevel">100%</span>
        <button onclick="adjustZoom(0.1)">‚ûï</button>
    </div>

    <script>
        let lastValidState = {
            rows: 16,
            cols: 16,
            symmetric: false
        };

        function safeUpdateGrid() {
            try {
                const previousState = { 
                    rows: document.getElementById('rows').value,
                    cols: document.getElementById('cols').value,
                    symmetric: state.symmetricGrid
                };
                
                // L√≥gica original de updateGrid()
                let rows = Math.max(8, Math.min(64, parseInt(document.getElementById('rows').value) || 16));
                let cols = Math.max(8, Math.min(64, parseInt(document.getElementById('cols').value) || 16));

                if(state.symmetricGrid) {
                    const newSize = Math.min(rows, cols);
                    rows = cols = newSize;
                    document.getElementById('rows').value = newSize;
                    document.getElementById('cols').value = newSize;
                } else {
                    rows = Math.min(rows, state.lastIndependentSize.rows);
                    cols = Math.min(cols, state.lastIndependentSize.cols);
                    document.getElementById('rows').value = rows;
                    document.getElementById('cols').value = cols;
                    state.lastIndependentSize = { rows, cols };
                }

                dom.grid.style.gridTemplateColumns = `repeat(${cols}, 20px)`;
                dom.grid.className = state.gridVisible ? 'grid-visible' : '';
                
                const fragment = document.createDocumentFragment();
                for(let i = 0; i < rows * cols; i++) {
                    fragment.appendChild(createPixel());
                }
                
                dom.grid.innerHTML = '';
                dom.grid.appendChild(fragment);
                state.isDrawing = false;

                // Actualizar estado v√°lido
                lastValidState = {
                    rows: document.getElementById('rows').value,
                    cols: document.getElementById('cols').value,
                    symmetric: state.symmetricGrid
                };
            } catch (error) {
                console.error('Error: Restaurando estado previo');
                document.getElementById('rows').value = lastValidState.rows;
                document.getElementById('cols').value = lastValidState.cols;
                state.symmetricGrid = lastValidState.symmetric;
                dom.symmetryStatus.textContent = lastValidState.symmetric ? "S√≠" : "No";
                updateGrid();
            }
        }

        const state = {
            currentColor: '#ff0000',
            currentTool: 'brush',
            gridVisible: true,
            isDrawing: false,
            currentZoom: 1,
            symmetricGrid: false,
            deleteQueue: null,
            mirrorMode: { active: false, type: 'vertical' },
            paletas: JSON.parse(localStorage.getItem('paletas')) || {
                'default': ['#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00']
            },
            currentPalette: 'default'
        };

        const dom = {
            grid: document.getElementById('grid'),
            colorInput: document.getElementById('colorInput'),
            colorPreview: document.getElementById('colorPreview'),
            confirmDialog: document.getElementById('confirmDialog'),
            paletteSelector: document.getElementById('paletteSelector'),
            symmetryStatus: document.getElementById('symmetryStatus'),
            zoomLevel: document.getElementById('zoomLevel')
        };

        function init() {
            setupEventListeners();
            updateGrid();
            updateColorPreview();
            initPalettes();
        }

        function updateGrid() {
            let rows = Math.max(8, Math.min(64, parseInt(document.getElementById('rows').value) || 16));
            let cols = Math.max(8, Math.min(64, parseInt(document.getElementById('cols').value) || 16));

            if(state.symmetricGrid) {
                rows = cols = Math.min(rows, cols);
                document.getElementById('rows').value = rows;
                document.getElementById('cols').value = cols;
            }

            dom.grid.style.gridTemplateColumns = `repeat(${cols}, 20px)`;
            dom.grid.className = state.gridVisible ? 'grid-visible' : '';
            
            const fragment = document.createDocumentFragment();
            for(let i = 0; i < rows * cols; i++) {
                fragment.appendChild(createPixel());
            }
            
            dom.grid.innerHTML = '';
            dom.grid.appendChild(fragment);
        }

        function createPixel() {
            const pixel = document.createElement('div');
            pixel.className = 'pixel';
            pixel.draggable = false;
            
            pixel.addEventListener('mousedown', startDrawing);
            pixel.addEventListener('mousemove', handleDrawing);
            pixel.addEventListener('touchstart', startDrawing);
            pixel.addEventListener('touchmove', handleTouchDrawing);
            
            return pixel;
        }

        function setupEventListeners() {
            dom.colorInput.addEventListener('input', e => {
                state.currentColor = e.target.value;
                updateColorPreview();
            });

            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    state.currentTool = this.dataset.tool;
                });
            });

            // Nuevos event listeners para dibujo continuo
            document.addEventListener('mousedown', function(e) {
                if (e.target.classList.contains('pixel')) {
                    state.isDrawing = true;
                    handleDrawing(e.target);  // Aplicar color inmediatamente en el primer pixel
                }
            });

            document.addEventListener('mousemove', function(e) {
                if (state.isDrawing && e.target.classList.contains('pixel')) {
                    handleDrawing(e.target);
                }
            });

            document.addEventListener('mouseup', stopDrawing);
            document.addEventListener('touchend', stopDrawing);

            // Prevenir el comportamiento predeterminado de selecci√≥n
            document.addEventListener('selectstart', function(e) {
                if (e.target.classList.contains('pixel')) {
                    e.preventDefault();
                }
            });
        }

        function startDrawing(e) {
            e.preventDefault();
            state.isDrawing = true;
            handleDrawing(e.target);
        }

        function handleDrawing(pixel) {
            if(!state.isDrawing || !pixel?.classList?.contains('pixel')) return;
            
            applyColor(pixel);
            if(state.mirrorMode.active) applyMirrorEffect(pixel);
            if(state.symmetricGrid) applySymmetry(pixel);
        }

        function stopDrawing() {
            state.isDrawing = false;
        }

        function applySymmetry(pixel) {
            const index = Array.from(dom.grid.children).indexOf(pixel);
            const total = dom.grid.children.length;
            const mirrorIndex = total - 1 - index;
            
            if(mirrorIndex >= 0 && mirrorIndex < total) {
                applyColor(dom.grid.children[mirrorIndex]);
            }
        }

        function applyMirrorEffect(originalPixel) {
            const index = Array.from(dom.grid.children).indexOf(originalPixel);
            const cols = parseInt(document.getElementById('cols').value);
            const rows = parseInt(document.getElementById('rows').value);
            const mirrorIndices = [];

            switch(state.mirrorMode.type) {
                case 'vertical':
                    mirrorIndices.push(Math.floor(index / cols) * cols + (cols - 1 - (index % cols)));
                    break;
                case 'horizontal':
                    mirrorIndices.push((rows - 1 - Math.floor(index / cols)) * cols + (index % cols));
                    break;
                case 'diagonal':
                    mirrorIndices.push(
                        Math.floor(index / cols) * cols + (cols - 1 - (index % cols)),
                        (rows - 1 - Math.floor(index / cols)) * cols + (index % cols)
                    );
                    break;
            }

            mirrorIndices.forEach(idx => {
                if(dom.grid.children[idx]) {
                    applyColor(dom.grid.children[idx]);
                }
            });
        }

        function applyColor(pixel) {
            if(!pixel) return;
            
            switch(state.currentTool) {
                case 'brush':
                    pixel.style.backgroundColor = state.currentColor;
                    break;
                case 'eraser':
                    pixel.style.backgroundColor = '#ffffff';
                    break;
                case 'fill':
                    floodFill(pixel);
                    break;
                case 'picker':
                    state.currentColor = pixel.style.backgroundColor;
                    updateColorPreview();
                    break;
            }
        }

        function floodFill(startPixel) {
            const targetColor = startPixel.style.backgroundColor;
            if(targetColor === state.currentColor) return;
            
            const queue = [startPixel];
            const visited = new Set();
            const cols = parseInt(document.getElementById('cols').value);
            
            while(queue.length > 0) {
                const current = queue.shift();
                if(!visited.has(current) && current.style.backgroundColor === targetColor) {
                    current.style.backgroundColor = state.currentColor;
                    visited.add(current);
                    
                    const index = Array.from(dom.grid.children).indexOf(current);
                    const neighbors = [];
                    
                    if(index % cols > 0) neighbors.push(index - 1);
                    if(index % cols < cols - 1) neighbors.push(index + 1);
                    if(index >= cols) neighbors.push(index - cols);
                    if(index < dom.grid.children.length - cols) neighbors.push(index + cols);
                    
                    neighbors.forEach(idx => {
                        if(!visited.has(dom.grid.children[idx])) {
                            queue.push(dom.grid.children[idx]);
                        }
                    });
                }
            }
        }

        function updateColorPreview() {
            dom.colorPreview.style.backgroundColor = state.currentColor;
        }

        function addToPalette() {
            const hexColor = rgbToHex(state.currentColor);
            if(!state.paletas[state.currentPalette].includes(hexColor)) {
                state.paletas[state.currentPalette].push(hexColor);
                renderPalette();
                savePalettes();
            }
        }

        function deleteColor(colorElement) {
            state.deleteQueue = {
                element: colorElement,
                color: rgbToHex(colorElement.querySelector('.color-swatch').style.backgroundColor)
            };
            const rect = document.querySelector('.color-picker').getBoundingClientRect();
            dom.confirmDialog.style.top = `${rect.bottom + 10}px`;
            dom.confirmDialog.style.left = `${rect.left + (rect.width/2 - 100)}px`;
            dom.confirmDialog.style.display = 'block';
        }

        function handleConfirm(response) {
            dom.confirmDialog.style.display = 'none';
            if(response && state.deleteQueue) {
                const colorIndex = state.paletas[state.currentPalette].findIndex(c => 
                    rgbToHex(c) === state.deleteQueue.color || c === state.deleteQueue.color
                );
                
                if(colorIndex > -1) {
                    state.paletas[state.currentPalette].splice(colorIndex, 1);
                    state.deleteQueue.element.remove();
                    savePalettes();
                }
            }
            state.deleteQueue = null;
        }

        function rgbToHex(rgb) {
            if (!rgb) return '#000000';
            if (rgb.startsWith('#')) return rgb.toLowerCase();
            
            const values = rgb.match(/\d+/g)?.map(Number) || [0,0,0];
            return '#' + values.map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        function toggleGrid() {
            state.gridVisible = !state.gridVisible;
            dom.grid.classList.toggle('grid-visible', state.gridVisible);
        }

        function toggleSymmetry() {
            state.symmetricGrid = !state.symmetricGrid;
            dom.symmetryStatus.textContent = state.symmetricGrid ? "Desactivar Simetria" : "Activar Simetria";
            updateGrid();
        }

        function adjustZoom(amount) {
            state.currentZoom = Math.max(0.5, Math.min(3, state.currentZoom + amount));
            document.getElementById('gridContainer').style.transform = `scale(${state.currentZoom})`;
            dom.zoomLevel.textContent = `${Math.round(state.currentZoom * 100)}%`;
        }

        function clearGrid() {
            document.querySelectorAll('.pixel').forEach(pixel => {
                pixel.style.backgroundColor = '#ffffff';
            });
        }

        function saveArt() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const scale = 20;
            const cols = parseInt(document.getElementById('cols').value);
            const rows = parseInt(document.getElementById('rows').value);
            
            canvas.width = cols * scale;
            canvas.height = rows * scale;
            ctx.imageSmoothingEnabled = false;

            document.querySelectorAll('.pixel').forEach((pixel, index) => {
                const x = (index % cols) * scale;
                const y = Math.floor(index / cols) * scale;
                ctx.fillStyle = pixel.style.backgroundColor || '#FFFFFF';
                ctx.fillRect(x, y, scale, scale);
            });

            const link = document.createElement('a');
            link.download = `pixel-art-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function initPalettes() {
            dom.paletteSelector.innerHTML = Object.keys(state.paletas).map(p => 
                `<option ${p === state.currentPalette ? 'selected' : ''}>${p}</option>`
            ).join('');
            renderPalette();
        }

        function newPalette() {
            const name = prompt('Nombre de la nueva paleta:');
            if(name && !state.paletas[name]) {
                state.paletas[name] = [];
                state.currentPalette = name;
                initPalettes();
                savePalettes();
            }
        }

        function changePalette(name) {
            state.currentPalette = name;
            renderPalette();
        }

        function renderPalette() {
            const container = document.getElementById('colorPalette');
            container.innerHTML = state.paletas[state.currentPalette].map(color => `
                <div class="color-swatch-container">
                    <div class="color-swatch" style="background: ${color}"></div>
                    <div class="delete-color" onclick="deleteColor(this.parentElement)"></div>
                </div>
            `).join('');
        }

        function savePalettes() {
            localStorage.setItem('paletas', JSON.stringify(state.paletas));
        }

        function toggleMirrorMode() {
            state.mirrorMode.active = !state.mirrorMode.active;
            document.querySelector('.mirror-controls button').classList.toggle('active');
        }

        function changeMirrorType(type) {
            state.mirrorMode.type = type;
        }

        function handleTouchDrawing(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const pixel = document.elementFromPoint(touch.clientX, touch.clientY);
            handleDrawing(pixel);
        }

        // Inicializar la aplicaci√≥n
        init();
    </script>
</body>
</html>